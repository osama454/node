<!DOCTYPE html>
<html>
<head>
<title>Interactive Geometry Playground</title>
<style>
body {
  font-family: sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: #f0f0f0;
}

#container {
  display: flex;
  flex-direction: column;
  background-color: #fff;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
}

canvas {
  border: 1px solid #ccc;
  cursor: move;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
  margin-bottom: 20px;
}

button,
select,
input[type="color"],
input[type="range"],
label {
  margin: 5px;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 3px;
  font-size: 16px;
}

label {
  display: block;
  margin-bottom: 5px;
}

#shapeCount {
  margin-left: 10px;
  font-weight: bold;
}
</style>
</head>
<body>
<div id="container">
  <h1>Interactive Geometry Playground</h1>
  <div class="controls">
    <button id="drawCircle">Draw Circle</button>
    <button id="drawSquare">Draw Square</button>
    <button id="drawTriangle">Draw Triangle</button>
    <button id="drawPentagon">Draw Pentagon</button>
    <button id="clearCanvas">Clear Canvas</button>
    <label for="gridSize">Grid Size:</label>
    <select id="gridSize">
      <option value="10">10px</option>
      <option value="20">20px</option>
      <option value="50">50px</option>
    </select>
    <label for="shapeSize">Shape Size:</label>
    <input type="range" id="shapeSize" min="10" max="100" value="50">
    <label for="borderColor">Border Color:</label>
    <input type="color" id="borderColor" value="#000000">
    <label for="borderWidth">Border Width:</label>
    <input type="range" id="borderWidth" min="1" max="10" value="2">
    <label for="animationToggle">Animation:</label>
    <input type="checkbox" id="animationToggle">
    <button id="saveShapes">Save Shapes</button>
    <button id="loadShapes">Load Shapes</button>
    <span>Shape Count: <span id="shapeCount">0</span></span>
  </div>
  <canvas id="myCanvas" width="800" height="600"></canvas>
</div>

<script>
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
const shapeCountDisplay = document.getElementById('shapeCount');
const drawCircleBtn = document.getElementById('drawCircle');
const drawSquareBtn = document.getElementById('drawSquare');
const drawTriangleBtn = document.getElementById('drawTriangle');
const drawPentagonBtn = document.getElementById('drawPentagon');
const clearCanvasBtn = document.getElementById('clearCanvas');
const gridSizeSelect = document.getElementById('gridSize');
const shapeSizeRange = document.getElementById('shapeSize');
const borderColorPicker = document.getElementById('borderColor');
const borderWidthRange = document.getElementById('borderWidth');
const animationToggle = document.getElementById('animationToggle');
const saveShapesBtn = document.getElementById('saveShapes');
const loadShapesBtn = document.getElementById('loadShapes');

let shapes = [];
let gridSize = 10;
let isDragging = false;
let selectedShape = null;
let offsetX, offsetY;
let animationFrameId;

// Function to draw a circle
function drawCircle(shape) {
  ctx.beginPath();
  ctx.arc(shape.x, shape.y, shape.size / 2, 0, 2 * Math.PI);
  const gradient = ctx.createLinearGradient(shape.x - shape.size / 2, shape.y - shape.size / 2, shape.x + shape.size / 2, shape.y + shape.size / 2);
  gradient.addColorStop(0, '#f0f');
  gradient.addColorStop(1, '#0ff');
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = shape.borderColor;
  ctx.lineWidth = shape.borderWidth;
  ctx.stroke();
}

// Function to draw a square
function drawSquare(shape) {
  ctx.beginPath();
  ctx.rect(shape.x - shape.size / 2, shape.y - shape.size / 2, shape.size, shape.size);
  const gradient = ctx.createLinearGradient(shape.x - shape.size / 2, shape.y - shape.size / 2, shape.x + shape.size / 2, shape.y + shape.size / 2);
  gradient.addColorStop(0, '#f00');
  gradient.addColorStop(1, '#0f0');
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = shape.borderColor;
  ctx.lineWidth = shape.borderWidth;
  ctx.stroke();
}

// Function to draw a triangle
function drawTriangle(shape) {
  const size = shape.size;
  ctx.beginPath();
  ctx.moveTo(shape.x, shape.y - size / 2);
  ctx.lineTo(shape.x - size / 2, shape.y + size / 2);
  ctx.lineTo(shape.x + size / 2, shape.y + size / 2);
  ctx.closePath();
  const gradient = ctx.createLinearGradient(shape.x - size / 2, shape.y - size / 2, shape.x + size / 2, shape.y + size / 2);
  gradient.addColorStop(0, '#00f');
  gradient.addColorStop(1, '#ff0');
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = shape.borderColor;
  ctx.lineWidth = shape.borderWidth;
  ctx.stroke();
}

// Function to draw a pentagon
function drawPentagon(shape) {
  const numberOfSides = 5;
  const size = shape.size / 2;
  const angle = (2 * Math.PI) / numberOfSides;
  ctx.beginPath();
  for (let i = 0; i <= numberOfSides; i++) {
    const currentAngle = i * angle;
    const currentX = shape.x + size * Math.cos(currentAngle);
    const currentY = shape.y + size * Math.sin(currentAngle);
    if (i === 0) {
      ctx.moveTo(currentX, currentY);
    } else {
      ctx.lineTo(currentX, currentY);
    }
  }
  ctx.closePath();
  const gradient = ctx.createLinearGradient(shape.x - size, shape.y - size, shape.x + size, shape.y + size);
  gradient.addColorStop(0, '#f0f');
  gradient.addColorStop(1, '#000');
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = shape.borderColor;
  ctx.lineWidth = shape.borderWidth;
  ctx.stroke();
}

// Function to draw all shapes
function drawShapes() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  shapes.forEach(shape => {
    ctx.save();
    ctx.translate(shape.x, shape.y);
    if (shape.rotation) {
      ctx.rotate(shape.rotation * Math.PI / 180);
    }
    ctx.translate(-shape.x, -shape.y);
    if (shape.type === 'circle') {
      drawCircle(shape);
    } else if (shape.type === 'square') {
      drawSquare(shape);
    } else if (shape.type === 'triangle') {
      drawTriangle(shape);
    } else if (shape.type === 'pentagon') {
      drawPentagon(shape);
    }
    ctx.restore();
  });
}

// Function to handle shape creation
function createShape(type) {
  const size = parseInt(shapeSizeRange.value);
  const x = Math.random() * (canvas.width - size) + size / 2;
  const y = Math.random() * (canvas.height - size) + size / 2;
  const borderColor = borderColorPicker.value;
  const borderWidth = parseInt(borderWidthRange.value);
  const newShape = { type, x, y, size, borderColor, borderWidth, rotation: 0 };
  shapes.push(newShape);
  shapeCountDisplay.textContent = shapes.length;
  drawShapes();
}

// Function to handle shape selection
function selectShape(x, y) {
  for (let i = shapes.length - 1; i >= 0; i--) {
    const shape = shapes[i];
    let path = new Path2D();
    if (shape.type === 'circle') {
      path.arc(shape.x, shape.y, shape.size / 2, 0, 2 * Math.PI);
    } else if (shape.type === 'square') {
      path.rect(shape.x - shape.size / 2, shape.y - shape.size / 2, shape.size, shape.size);
    } else if (shape.type === 'triangle') {
      path.moveTo(shape.x, shape.y - shape.size / 2);
      path.lineTo(shape.x - shape.size / 2, shape.y + shape.size / 2);
      path.lineTo(shape.x + shape.size / 2, shape.y + shape.size / 2);
      path.closePath();
    } else if (shape.type === 'pentagon') {
      const numberOfSides = 5;
      const size = shape.size / 2;
      const angle = (2 * Math.PI) / numberOfSides;
      for (let j = 0; j < numberOfSides; j++) {
        const currentAngle = j * angle;
        const currentX = shape.x + size * Math.cos(currentAngle);
        const currentY = shape.y + size * Math.sin(currentAngle);
        if (j === 0) {
          path.moveTo(currentX, currentY);
        } else {
          path.lineTo(currentX, currentY);
        }
      }
      path.closePath();
    }
    if (ctx.isPointInPath(path, x, y)) {
      return shape;
    }
  }
  return null;
}

// Function to handle shape dragging
function handleMouseDown(e) {
  const mouseX = e.offsetX;
  const mouseY = e.offsetY;
  selectedShape = selectShape(mouseX, mouseY);
  if (selectedShape) {
    isDragging = true;
    offsetX = mouseX - selectedShape.x;
    offsetY = mouseY - selectedShape.y;
  }
}

function handleMouseMove(e) {
  if (isDragging && selectedShape) {
    selectedShape.x = e.offsetX - offsetX;
    selectedShape.y = e.offsetY - offsetY;
    drawShapes();
  }
}

function handleMouseUp() {
  if (isDragging && selectedShape) {
    // Snap to grid
    selectedShape.x = Math.round(selectedShape.x / gridSize) * gridSize;
    selectedShape.y = Math.round(selectedShape.y / gridSize) * gridSize;
    drawShapes();
  }
  isDragging = false;
  selectedShape = null;
}

// Function to handle shape deletion
function handleDoubleClick(e) {
  const mouseX = e.offsetX;
  const mouseY = e.offsetY;
  const shapeToDelete = selectShape(mouseX, mouseY);
  if (shapeToDelete) {
    shapes = shapes.filter(shape => shape !== shapeToDelete);
    shapeCountDisplay.textContent = shapes.length;
    drawShapes();
  }
}

// Function to handle shape rotation
function handleKeyDown(e) {
  if (selectedShape) {
    const angle = 10;
    if (e.key === 'ArrowUp') {
      selectedShape.rotation = (selectedShape.rotation || 0) + angle;
    } else if (e.key === 'ArrowDown') {
      selectedShape.rotation = (selectedShape.rotation || 0) - angle;
    } else if (e.key === 'ArrowLeft') {
      selectedShape.rotation = (selectedShape.rotation || 0) - angle;
    } else if (e.key === 'ArrowRight') {
      selectedShape.rotation = (selectedShape.rotation || 0) + angle;
    }
    drawShapes();
  }
}

// Function to animate shapes
function animateShapes() {
  if (animationToggle.checked) {
    shapes.forEach(shape => {
      // Example animation: slowly rotate shapes
      shape.rotation = (shape.rotation || 0) + 1;
    });
    drawShapes();
    animationFrameId = requestAnimationFrame(animateShapes);
  } else {
    cancelAnimationFrame(animationFrameId);
  }
}

// Function to save shapes to a JSON file
function saveShapes() {
  const dataStr = JSON.stringify(shapes);
  const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
  const exportFileDefaultName = 'shapes.json';

  let linkElement = document.createElement('a');
  linkElement.setAttribute('href', dataUri);
  linkElement.setAttribute('download', exportFileDefaultName);
  linkElement.click();
}

// Function to load shapes from a JSON file
function loadShapes(event) {
  const file = event.target.files[0];
  const reader = new FileReader();
  reader.onload = (e) => {
    shapes = JSON.parse(e.target.result);
    shapeCountDisplay.textContent = shapes.length;
    drawShapes();
  };
  reader.readAsText(file);
}

// Event listeners
drawCircleBtn.addEventListener('click', () => createShape('circle'));
drawSquareBtn.addEventListener('click', () => createShape('square'));
drawTriangleBtn.addEventListener('click', () => createShape('triangle'));
drawPentagonBtn.addEventListener('click', () => createShape('pentagon'));
clearCanvasBtn.addEventListener('click', () => {
  shapes = [];
  shapeCountDisplay.textContent = 0;
  drawShapes();
});
gridSizeSelect.addEventListener('change', () => {
  gridSize = parseInt(gridSizeSelect.value);
});
shapeSizeRange.addEventListener('input', drawShapes);
borderColorPicker.addEventListener('input', drawShapes);
borderWidthRange.addEventListener('input', drawShapes);
animationToggle.addEventListener('change', animateShapes);
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('dblclick', handleDoubleClick);
document.addEventListener('keydown', handleKeyDown);
saveShapesBtn.addEventListener('click', saveShapes);
loadShapesBtn.addEventListener('change', loadShapes);

// Initial drawing
drawShapes();
</script>
<input type="file" id="fileInput" style="display: none;" />
<script>
  loadShapesBtn.addEventListener('click', () => {
    document.getElementById('fileInput').click();
  });

  document.getElementById('fileInput').addEventListener('change', loadShapes);
</script>
</div>
</body>
</html>